# JMM主内存,工作内存

**当线程释放一个锁时**: 会强制性的将工作内存中之前所有的写操作都刷新到主内存中去

**获取一个锁**: 会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段，即刷新工作缓存

## Context Switch

相关操作：sleep、wait、yield、join、park、synchronized、lock

上下文切换的系统开销
  1. 操作系统保存和恢复上下文
  2. 调度器进行线程调度
  3. 处理器高速缓存重新加载(即被动刷新工作缓存)
  4. 可能导致整个高速缓存区被冲刷，从而带来时间开销

`volatile`关键字的作用是保证可见性和有序性(不会指令重排)，volatile的读写操作不会导致上下文切换，开销较小.
由于volatile关键字没有锁的排它性，因此不能保证操作变量的原子性

CAS不会导致上下文切换，Java的Atomic包就使用了CAS算法来更新数据，而不需要额外加锁


# 指令重排对单线程和多线程的影响

## 单线程
对于单线程而言，因为编译器、runtime和处理器都必须遵守as-if-serial语义。不管怎么重排序，单线程的执行结果不会改变。所以我们不需要考虑指令重排带来的危害，只需要享受它带给我们的好处就可以了。

## 多线程

对于多线程来说，指令重排就可能会给我们带来极大的危害（参照单例模式双重检查机制）.通过内存屏障禁止重排序：JMM通过插入特定类型的内存屏障，来禁止特定类型的编译器重排序和处理器重排序.

## 指令重排序需要遵守happens-before规则

**一个操作"时间上的先发生"不代表这个操作会是"先行发生"**

```java
private int value = 0;

pubilc void setValue(int value){
	this.value = value;
}

public int getValue(){
	return value;
}
```

假设存在线程A和B，线程A先（时
间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值
是什么？

由于两个方法分别由线程A和B调用，不在一个线
程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管
程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线
程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规
则，所以最后一条传递性也无从谈起，因此我们可以判定，尽管线程A在操作时间上先于线程B，但是
无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的.

把value定义为volatile变量，由于setter方
法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来
实现先行发生关系

**如果一个操作"先行发生"，是否就能推导出这个操作必定是"时间上的先发生"呢？很遗憾，这个推论也是不成立的。一个典型的例子就是多次提到的"指令重排序"**

```java
// 以下操作在同一个线程中执行
int i = 1;
int j = 2;
```
两条赋值语句在同一个线程之中，根据程序次序规则，"int i=1"的操作先行
发生于"int j=2"，但是"int j=2"的代码完全可能先被处理器执行(即happen-before可能时间上后执行)，这并不影响先行发生原则的正确性，
因为我们在这条线程之中没有办法感知到这一点

时间先后顺序与先行发生原则之间基本没有因果关系，
所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准

# 内存屏障

内存屏障或内存栅栏(Memory Barrier)，是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术. 就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的有序性。强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的可见性。

内存屏障有三种类型

  1. lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
  2. sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
  3. mfence：即全能屏障，具备ifence和sfence的能力。
  4. Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能。

在Java中：实现了内存屏障的技术有volatile。volatile就是用Lock前缀方式的内存屏障伪类型来实现的
